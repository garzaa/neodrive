using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.Splines;
using Unity.Mathematics;
using System.Linq;

[ExecuteInEditMode]
public class MeshRoad : MonoBehaviour {
	public Mesh baseMesh;
	private GameObject generated;
	public Material baseMaterial;
	public PhysicMaterial physicMaterial;
	public SplineContainer splineContainer;

	[Tooltip("Translation to apply on the mesh before bending it.")]
	public Vector3 translation;
	[Tooltip("Rotation to apply on the mesh before bending it.")]
	public Vector3 rotation;
	[Tooltip("Scale to apply on the mesh before bending it.")]
	public Vector3 scale = Vector3.one;

	[Tooltip("The mode to use to fill the choosen interval with the bent mesh.")]
	public MeshBender.FillingMode mode = MeshBender.FillingMode.Repeat;

	void Start() {
		 string generatedName = "generated by " + GetType().Name;
            var generatedTranform = transform.Find(generatedName);
            generated = generatedTranform != null ? generatedTranform.gameObject : SplineMesh.UOUtility.Create(generatedName, gameObject);
		BuildMesh();
	}

	void Update() {
		if (Application.isEditor) {
			BuildMesh();
		}
	}

	// ok. need to take the splinemesh stuff, rip it out, and drop it in here
	// the prefab stuff is too nice to not have
	// and unity's native spline editing tools are fucking nice
	void BuildMesh() {
		#if UNITY_EDITOR
            // we don't update if we are in prefab mode
            if (UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage() != null) return;
		#endif
		var used = new List<GameObject>();

		var go = FindOrCreate("segment 1 mesh");
		go.GetComponent<MeshCollider>().enabled = true;
		// ok this needs to be 0 in the second to fill the entire way
		// i see. there need to be multiple meshBenders here?
		// but then why is it repeating them on the same interval
		// fuck it, just grab GetBent on the vertex and apply it to the mesh. do this tomorrow
		// that'll be a nice thing to look forward to
		go.GetComponent<MeshBender>().SetInterval(splineContainer, 0, 0);
		go.GetComponent<MeshBender>().SetDirty();
		used.Add(go);

		foreach (var g in generated.transform
			.Cast<Transform>()
			.Select(child => child.gameObject).Except(used)) {
			SplineMesh.UOUtility.Destroy(g);
		}
	}

	private GameObject FindOrCreate(string name) {
		var childTransform = generated.transform.Find(name);
		GameObject res;
		if (childTransform == null) {
			res = SplineMesh.UOUtility.Create(name,
				generated,
				typeof(MeshFilter),
				typeof(MeshRenderer),
				typeof(MeshBender),
				typeof(MeshCollider));
			res.isStatic = true;
		} else {
			res = childTransform.gameObject;
		}
		res.GetComponent<MeshRenderer>().material = baseMaterial;
		res.GetComponent<MeshCollider>().material = physicMaterial;
		MeshBender mb = res.GetComponent<MeshBender>();
		mb.Source = SplineMesh.SourceMesh.Build(baseMesh)
			.Translate(translation)
			.Rotate(Quaternion.Euler(rotation))
			.Scale(scale);
		mb.Mode = mode;
		return res;
	}
}
