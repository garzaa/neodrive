using UnityEngine;
using UnityEditor;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Splines;
using Unity.Mathematics;

[DisallowMultipleComponent]
[RequireComponent(typeof(MeshFilter))]
[ExecuteInEditMode]
public class MeshBender : MonoBehaviour {
	private bool isDirty = false;
	private Mesh result;
	private bool useSpline;
	private SplineContainer spline;
	private float intervalStart, intervalEnd;
	float3 position, tangent, up, right;
	private Dictionary<float, SplineMesh.CurveSample> sampleCache = new Dictionary<float, SplineMesh.CurveSample>();

	private SplineMesh.SourceMesh source;
	/// <summary>
	/// The source mesh to bend.
	/// </summary>
	public SplineMesh.SourceMesh Source {
		get { return source; }
		set {
			if (value == source) return;
			SetDirty();
			source = value;
		}
	}
	
	private FillingMode mode = FillingMode.StretchToInterval;
	/// <summary>
	/// The scaling mode along the spline
	/// </summary>
	public FillingMode Mode {
		get { return mode; }
		set {
			if (value == mode) return;
			SetDirty();
			mode = value;
		}
	}

	/// <summary>
	/// Sets a spline's interval along which the mesh will be bent.
	/// If interval end is absent or set to 0, the interval goes from start to spline length.
	/// The mesh will be update if any of the curve changes on the spline, including curves
	/// outside the given interval.
	/// </summary>
	/// <param name="spline">The <see cref="SplineMesh"/> to bend the source mesh along.</param>
	/// <param name="intervalStart">Distance from the spline start to place the mesh minimum X.<param>
	/// <param name="intervalEnd">Distance from the spline start to stop deforming the source mesh.</param>
	public void SetInterval(SplineContainer spline, float intervalStart, float intervalEnd = 0) {
		if (this.spline == spline && this.intervalStart == intervalStart && this.intervalEnd == intervalEnd) return;
		if (spline == null) throw new ArgumentNullException("spline");
		if (intervalStart < 0 || intervalStart >= spline.CalculateLength()) {
			throw new ArgumentOutOfRangeException("interval start must be 0 or greater and lesser than spline length (was " + intervalStart + ")");
		}
		if (intervalEnd != 0 && intervalEnd <= intervalStart || intervalEnd > spline.CalculateLength()) {
			throw new ArgumentOutOfRangeException("interval end must be 0 or greater than interval start, and lesser than spline length (was " + intervalEnd + ")");
		}
		this.spline = spline;
		// listening new spline
		Spline.Changed += SetDirty;

		this.intervalStart = intervalStart;
		this.intervalEnd = intervalEnd;
		useSpline = true;
		SetDirty();
	}

	private void OnEnable() {
		if(GetComponent<MeshFilter>().sharedMesh != null) {
			result = GetComponent<MeshFilter>().sharedMesh;
		} else {
			GetComponent<MeshFilter>().sharedMesh = result = new Mesh();
			result.name = "Generated by " + GetType().Name;
		}
	}

	private void LateUpdate() {
		ComputeIfNeeded();
	}

	public void ComputeIfNeeded() {
		if (isDirty) {
			Compute();
		}
	}

	private void SetDirty(Spline s, int i, SplineModification sm) {
		if (s == spline.Splines[0]) isDirty = true;
	}

	public void SetDirty() {
		isDirty = true;
	}

	/// <summary>
	/// Bend the mesh. This method may take time and should not be called more than necessary.
	/// Consider using <see cref="ComputeIfNeeded"/> for faster result.
	/// </summary>
	private  void Compute() {
		isDirty = false;
		switch (Mode) {
			case FillingMode.Once:
				FillOnce();
				break;
			case FillingMode.Repeat:
				FillRepeat();
				break;
			case FillingMode.StretchToInterval:
				FillStretch();
				break;
		}
	}

	/// <summary>
	/// The mode used by <see cref="MeshBender"/> to bend meshes on the interval.
	/// </summary>
	public enum FillingMode {
		/// <summary>
		/// In this mode, source mesh will be placed on the interval by preserving mesh scale.
		/// Vertices that are beyond interval end will be placed on the interval end.
		/// </summary>
		Once,
		/// <summary>
		/// In this mode, the mesh will be repeated to fill the interval, preserving
		/// mesh scale.
		/// This filling process will stop when the remaining space is not enough to
		/// place a whole mesh, leading to an empty interval.
		/// </summary>
		Repeat,
		/// <summary>
		/// In this mode, the mesh is deformed along the X axis to fill exactly the interval.
		/// </summary>
		StretchToInterval
	}

	private void FillOnce() {
		sampleCache.Clear();
		float length = spline.CalculateLength();
		var bentVertices = new List<SplineMesh.MeshVertex>(source.Vertices.Count);
		// for each mesh vertex, we found its projection on the curve
		foreach (var vert in source.Vertices) {
			float distance = vert.position.x - source.MinX;
			if (!sampleCache.TryGetValue(distance, out SplineMesh.CurveSample sample)) {
				float distOnSpline = intervalStart + distance;
				if (distOnSpline > length) {
					if (spline.Splines[0].Closed) {
						while (distOnSpline > length) {
							distOnSpline -= length;
						}
					} else {
						distOnSpline = length;
					}
				}
				sample = GetSampleAtDistance(distOnSpline);
				sampleCache[distance] = sample;
			}

			bentVertices.Add(sample.GetBent(vert));
		}

		SplineMesh.MeshUtility.Update(result,
			source.Mesh,
			source.Triangles,
			bentVertices.Select(b => b.position),
			bentVertices.Select(b => b.normal));
	}

	private void FillRepeat() {
		print("filling repeat");
		float length = spline.CalculateLength();
		// this could be stretched a bit. oh well, that seems hard
		int repetitionCount = Mathf.FloorToInt(length / source.Length);


		// building triangles and UVs for the repeated mesh
		var triangles = new List<int>();
		var uv = new List<Vector2>();
		var uv2 = new List<Vector2>();
		var uv3 = new List<Vector2>();
		var uv4 = new List<Vector2>();
		var uv5 = new List<Vector2>();
		var uv6 = new List<Vector2>();
		var uv7 = new List<Vector2>();
		var uv8 = new List<Vector2>();
		// ok so it adds 47 copies of the triangles
		for (int i = 0; i < repetitionCount; i++) {
			foreach (var index in source.Triangles) {
				triangles.Add(index + source.Vertices.Count * i);
			}
			uv.AddRange(source.Mesh.uv);
			uv2.AddRange(source.Mesh.uv2);
			uv3.AddRange(source.Mesh.uv3);
			uv4.AddRange(source.Mesh.uv4);
#if UNITY_2018_2_OR_NEWER
			uv5.AddRange(source.Mesh.uv5);
			uv6.AddRange(source.Mesh.uv6);
			uv7.AddRange(source.Mesh.uv7);
			uv8.AddRange(source.Mesh.uv8);
#endif
		}

		// computing vertices and normals
		var bentVertices = new List<SplineMesh.MeshVertex>(source.Vertices.Count);
		float offset = 0;
		// so it does this 47 times. each time, it stretches the mesh across the entire thing
		// need to not do that lol
		// this should really be - every segment is the same gameobject
		// so ok, set the interval up top and add a new mesh combiner for each one? goddamn
		for (int i = 0; i < repetitionCount; i++) {
			sampleCache.Clear();
			// for each mesh vertex, we found its projection on the curve
			foreach (var vert in source.Vertices) {
				float distance = vert.position.x - source.MinX + offset;
				SplineMesh.CurveSample sample;
				if (!sampleCache.TryGetValue(distance, out sample)) {
					float distOnSpline = intervalStart + distance;
					while (distOnSpline > length) {
						distOnSpline -= length;
					}
					sample = GetSampleAtDistance(distOnSpline);
					sampleCache[distance] = sample;
				}
				bentVertices.Add(sample.GetBent(vert));
			}
			offset += source.Length;
		}

		SplineMesh.MeshUtility.Update(result,
			source.Mesh,
			triangles,
			bentVertices.Select(b => b.position),
			bentVertices.Select(b => b.normal),
			uv,
			uv2,
			uv3,
			uv4,
			uv5,
			uv6,
			uv7,
			uv8);
	}

	private void FillStretch() {
		float length = spline.CalculateLength();
		var bentVertices = new List<SplineMesh.MeshVertex>(source.Vertices.Count);
		sampleCache.Clear();
		// for each mesh vertex, we found its projection on the curve
		foreach (var vert in source.Vertices) {
			float distanceRate = source.Length == 0 ? 0 : Math.Abs(vert.position.x - source.MinX) / source.Length;
			SplineMesh.CurveSample sample;
			if (!sampleCache.TryGetValue(distanceRate, out sample)) {
				float intervalLength = intervalEnd == 0 ? length - intervalStart : intervalEnd - intervalStart;
				float distOnSpline = intervalStart + intervalLength * distanceRate;
				if(distOnSpline > length) {
					distOnSpline = length;
					Debug.Log("dist " + distOnSpline + " spline length " + length + " start " + intervalStart);
				}

				sample = GetSampleAtDistance(distOnSpline);
				sampleCache[distanceRate] = sample;
			}

			bentVertices.Add(sample.GetBent(vert));
		}

		SplineMesh.MeshUtility.Update(result,
			source.Mesh,
			source.Triangles,
			bentVertices.Select(b => b.position),
			bentVertices.Select(b => b.normal));
		if (TryGetComponent(out MeshCollider collider)) {
			collider.sharedMesh = result;
		}
	}

	private SplineMesh.CurveSample GetSampleAtDistance(float t) {
		if (t < 0 || t > spline.CalculateLength()) {
			throw new ArgumentException(string.Format("Distance must be between 0 and spline length ({0}). Given distance was {1}.", spline.CalculateLength(), t));
		}
		spline.Evaluate(t, out position, out tangent, out up);
		return new SplineMesh.CurveSample(
			position,
			tangent,
			up,
			Vector2.one,
			0,
			t * spline.CalculateLength(),
			t,
			null
		);
	}
}
